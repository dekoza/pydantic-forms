from typing import Dict, Optional, Type, Any
from typing import Generic, TypeVar

import pydantic
from pydantic import BaseModel
from pydantic.generics import GenericModel

from pydantic_forms.interfaces import BaseStrategy
from pydantic_forms.objects import FormField
from pydantic_forms.strategies import DefaultStrategy
from .services import make_form_fields, format_validation_error_schemas, get_field_errors

T = TypeVar('T')


class PydanticForm(GenericModel, Generic[T]):
    """
    .. note::
        You will not manually construct this class, but instead use one of two classmethods for instantiation.


    This serves as the main manager for handling form resolution with Pydantic.
    The object itself subclasses `pydantic.BaseModel` and has all features of a Pydantic model.

    Parameters
    ----------
    csrf:
        Represents a csrf token string that is generated by a Strategy.

        * :func:`create() <PydanticForm.create>` creates the attribute to allow the user to embed it in hidden fields on the client.
        * :func:`validate_request() <PydanticForm.validate_request>` will have the results of the form data

        Pydantic-Forms expects and requires you to embed this token on each one of your HTML forms whether as a hidden field or otherwise.

    fields:
        A dictionary of all fields that are in the schema with the key being the form field name and the value being a
        FormField object.

    model:
        The populated schema from the Pydantic model itself.

        * :func:`create() <PydanticForm.create>` will always have the model as None
        * :func:`validate_request <Pydantic.validate_request` will have the model as the pydantic model if validation was successful. Otherwise, None
    """
    csrf: str
    fields: Dict[str, FormField]
    model: Optional[T]

    @classmethod
    async def create(cls, request: Any, schema: Type[BaseModel], strategy: BaseStrategy = DefaultStrategy()) -> 'PydanticForm':
        """
        Creates the PydanticForm object from a typical request object. This method is generally called on a `GET` method
        for a particular endpoint.

        .. code-block:: python3

            # Fast API Example
            from pydantic import BaseModel
            from fastapi.requests import Request
            templates = Jinja2Templates(directory="my/template/directory")

            class MyForm(BaseModel):
                name: str
                age: int

            @app.get('/form', response_class=HTMLResponse)
            async def my_form(request: Request):
                form = PydanticForm.create(request, MyForm)
                return templates.TemplateResponse("/users/register.html", {"request": request, 'form': form})

        Parameters
        ----------
        request:
            The webserver 'request' object that is returned from the user.
        schema:

            The class on which will act as the storage point for form data. This means that Pydantic models are flat
            with no nested models. All the magic of a normal BaseModel will work towards server-side validation such as
            validators.
        strategy:
            An instance that is inherited from BaseStrategy that is used to interpret the request object, insert csrf tokens
            into the session, and to parse validation errors that are returned from pydantic.

            If no instance is supplied, a DefaultStrategy is used which is compatable with FastAPI async request objects.

        Returns
        -------
        :class:`PydanticForm <PydanticForm>`
        """
        form_fields = make_form_fields(None, schema, {})
        csrf = await strategy.make_csrf()
        await strategy.attach_csrf(request, csrf)
        return cls[schema](csrf=csrf, fields=form_fields, model=None)

    @classmethod
    async def validate_request(cls, request: Any, schema: Type[BaseModel], strategy: BaseStrategy = DefaultStrategy()) -> 'PydanticForm':
        """
        Creates the PydanticForm object from a typical request object. This method is generally called on a `POST` method
        for a particular endpoint where it will then retrieve the form data.

        .. code-block:: python3

            # Fast API Example
            from pydantic import BaseModel
            from fastapi.requests import Request
            templates = Jinja2Templates(directory="my/template/directory")

            class MyForm(BaseModel):
                name: str
                age: int

            @app.post('/form', response_class=HTMLResponse)
            async def my_form(request: Request):
                form = await PydanticForm.validate_request(request, MyForm)
                if form.is_valid:
                    model = form.model
                    return f"Hello {model.name}, you are {model.age} years old"
                else:
                    return templates.TemplateResponse("/users/register.html", {"request": request, 'form': form})

        **If the form data received from the request object is valid**
            * The model attribute will contain the Pydantic instance from schema.
            * The FormField information in fields will be
                * error will contain an empty string
                * value will contain the validated value the user submitted and is equal to the attribute on the model

        **If the form data caused a ValidationError**
            * The model attribute will be None
            * The FormField information in fields will be
                * error will contain the validation error message
                * value will contain the data the form data that was submitted by the user



        Parameters
        ----------
        request
            The webserver 'request' object that is returned from the user.
        schema
            The class on which will act as the storage point for form data. This means that Pydantic models are flat
            with no nested models. All the magic of a normal BaseModel will work towards server-side validation such as
            validators.
        strategy
            An instance that is inherited from BaseStrategy that is used to interpret the request object as well as
            provide csrf generation and checks

            If no instance is supplied, a DefaultStrategy is used which is compatible with FastAPI async request objects

        Returns
        -------
        :class:`PydanticForm <PydanticForm>`
        """
        data = await strategy.get_request_data(request)
        csrf_key = strategy.csrf_key
        csrf_form_data = data.get(csrf_key)
        values, field_set, exc = pydantic.validate_model(schema, data)
        errors = []
        model = None
        if exc:
            errors = format_validation_error_schemas(exc)
        else:
            model = schema(**data)
        await strategy.csrf_check(request, csrf_form_data)
        field_errors = get_field_errors(errors)
        form_fields = make_form_fields(model, schema, field_errors, data)
        return cls[schema](fields=form_fields, model=model, csrf=csrf_form_data)

    @property
    def is_valid(self) -> bool:
        """
        A check if the form submission is valid and the model exists.
        Returns
        -------
        :class:`bool`
        """

        def no_error(form_field: FormField):
            return form_field.error == ''

        return all(no_error(ff) for ff in self.fields.values()) and self.model is not None

    @property
    def validated(self):
        """
        Checks if the form has been validated. Useful for determining form state for client-side formatting.

        Returns
        -------
        :class:`bool`
        """

        def predicate(form_field: FormField):
            return form_field.value != '' or form_field.error != ''

        return any(predicate(ff) for ff in self.fields.values())
